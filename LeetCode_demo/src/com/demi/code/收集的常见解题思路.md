## 贪心算法
### 答题思路（没有固定套路）
    局部最优：当前可移动的距离尽可能多走，如果还没到终点，记录下一个位置的值，继续往前走
    全局最优：每一步都尽可能多的走，直到终点位置。

### 目前接触到的贪心算法可解的题有：
    45, 53, 55

## 回溯
### 可以用到回溯的题型：
    排列、组合、切割、子集、棋盘等等。
### 如何理解回溯法
    回溯法能够解决的问题都可以形成**树形结构**。对于树的代码处理：横向对应for循环；纵向对应递归。
### 答题思路：
    void backtracking(参数) {
        if (终止条件) {
            收集结果；
            return;
        }
        for (集合元素) {
            处理节点;
            递归函数;
            回溯操作...
        }
        return;
    }
    
### 回溯函数如何构造（三部曲）：
    
    (1) 递归函数参数返回值以及参数;
    (2) 确定终止条件；一般来说，搜到叶子节点，也就找到了已调配满足条件的答案了，保存该答案，并结束本次递归。
    (3) 单层递归的实现逻辑。
    以LeetCode第77题为例：
    void backTracking(n, k, startIndex) {
        if (path.length == k) {
            res.add(path);
            return;
        }

        for (int i = startIndex; i <= n; i++) {
            path.add(i);
            backTracking(n, k, i + 1);
            path.remove(i);
        }
    }
### 回溯的题
    46, 47, 51
### 调优可以考虑的几个方向：
    
    1. 遍历中的i++改成++i；
    2. 对于数组题型，首先考虑是否可以将数组排序后再进行接下去的操作。


## 动态规划
### 动态规划的求解思路：五部曲
    (1) 确定dp数组以及下标的含义；
    (2) 确定递推公式；
    (3) dp数组的初始化；
    (4) 确定遍历顺序；
    (5) 举例推导dp数组。
### 例题实践
    Q62 不同路径问题：机器人从(0, 0)位置出发，到(m - 1, n - 1)位置到达终点的不同路径数。
    按照动态规划五部曲分析：
    (1) 确定dp数组以及下标的含义：
        dp[i][j]：表示从(0, 0)出发，到(i, j)有dp[i][j]条不同的路径。
    (2) 确定递推公式：
        想要求dp[i][j]，只能有两个方向推导出的结果：向下，到(i - 1, j)的路径数dp[i - 1][j]有关；向右，到(i, j - 1)的路径数dp[i][j - 1]有关。
        dp[i - 1][j]是从(0, 0)出发，到(i - 1, j)有dp[i - 1][j]条不同的路径，dp[i][j - 1]同理。
        那么，dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，因为dp[i][j]只有从这两个方向过来。
    (3) dp数组的初始化
        首先，dp[i][0]一定都是0，因为从(0, 0)到(i, 0)的路径只有一条，dp[0][j]同理。
        所以初始化代码为：
        for (int i = 0; i < m; i++) dp[i][0] = 1;
        for (int j = 0; j < n; j++) dp[0][j] = 1;
    (4) 确定遍历顺序
        主要依据是递推公式dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，dp[i][j]都是从上方和左方推导出来的，那么从左到右一层一层遍历就好了。
    (5) 动手举例推导dp数组。